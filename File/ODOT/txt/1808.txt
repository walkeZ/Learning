day0806：
1.会想起周五和candy聊天，说到子华不仅有天赋潜质，更重要是“用心”
  结合子华的表现与自我的对比。目前发现："用心"="行动"+"想法"，
  为"想法"付之实际行动，认真一步一步前行。

day0813
1.window，快速切换窗口：Alt+Tab【回访】，window标志(“田”字)+Tab【任务窗口选择】



day0815
1.使用git获取公司远程项目(Bitbucket上)：
  正确流程：1.先问好git账号【这是公司帮忙注册的，ps:https://git.infinitus.com.cn/】,
	    2.尝试登录(需要公司上级授予权限，否则提示：You do not have permission to access Bitbucket)
	    3.询问公司项目仓库地址(Bitbucket上)，并尝试打开(直接浏览器粘贴地址)。发现也要权限(提示：You are not permitted to view this page.)

	PS：需要先安装并配置git，然后再本地(自己电脑)中生成公钥，用于之后配置的远程仓库上，这样才可以使用SSH(加密，可提交，https不可提交)访问远程仓库。
	参考：https://blog.csdn.net/sihai12345/article/details/72379831  【github】

2.Sourcetree使用：Sourcetree是可视化、免费的gi代码管理工具
  ①安装：参考：https://blog.csdn.net/u012230055/article/details/64125268
  ②使用时发现：刚安装好，打开使用时需要登录Bitbucket或Atlassian账号，这两个账号的注册都需要翻墙(子华再用蓝灯:https://github.com/getlantern/lantern)
  ③解决②的问题：跳过账号登录，参考：http://www.cnblogs.com/xiofee/p/sourcetree_pass_initialization_setup.html


  
day0816:
1.模拟器安装失败并提示：INSTALL_FAILED_NO_MATCHING_ABIS 
参考：https://blog.csdn.net/rznice/article/details/40260339
原因：是由于使用了native libraries 。该native libraries 不支持当前的cpu的体系结构。【猜测：类似计步的api】
	  真机不会报(该)错

2.思考：静态变量会不会导致内存泄漏？
	当一个类有一个静态变量(static)时。因为被static修饰的变量将会随着类的加载而分配内存，即static变量是常驻内存的，
	故其对应的类也会一直在jvm内存中？
	
	ps：---------解析一个情况------------
	问题，Java中静态成员是随着类的加载而分配空间(内存)的[这点没错吧？①]，那么类的加载是在什么时候呢？
	从资源消耗角度去思考：类的加载应该在类被调用(引用)的时候才加载。
	静态变量是在类的加载的时候分配空间的，静态变量和对象没有关系，是在JVM第一次读到一个类的时候，加载信息的过程中
	分配空间的。加载过程为：1.加载父类(如果父类已经加载过)->2.初始化静态属性->3.按顺序的初始化static修饰的模块。
	结合普通成员变量的情况会更好理解。
	//百度：java中的全局变量和静态变量是在编译时分配内存还是在加载时分配内存??
	// --  https://zhidao.baidu.com/question/1946128931073999348.html
	
	ps_1：JVM第一次读到一个类的时候的理解
	纯工具类一般是没有对象的，也不会new对象，其静态成员是通过类名+.调用的，是在程序中第一次调用这个工具类的某个
	成员变量的时候。【应该是程序走到了(检索到)类名代码的时候。】
	
	//①我的理解是:没错。随着类的加载,jvm会在一个地方(方法区)里,会给该类的所有成员变量一次性分配好内存
	   (一次性，原因没听说有优先级或其他区别对待)，但也仅分配内存而已。比如一个静态全局变量static Object ob;
	   这时ob分配到了一个内存地址(引用)，但由于没有初始化，故其值应为null[有异议，当有地址引用时不为空，明天
	   回公司验证一下：log输出ob看看]，而如果是int 其值为0[这点也可以随便验证一番]。静态方法，也仅分配了一个
	   空间(内存)用于存放方法里的代码块。并未有调用，即仅在类的加载过程中不能仅通过在静态方法中输出log去做验证。
	   而Java中jvm对类的加载应该只有一次【从资源消耗角度去思考】。故每个对应的静态成员只有一个地址(所有对象共享)。
	   引出问题：为什么说一个类的所有对象共享一个静态变量(成员)你呢？
	   个人理解：因为static是常驻型内存(相对独立的内存空间)，不会被回收(?),每new一个对象，其对应的静态成员都指向
	   同一个内存地址。
	
	



